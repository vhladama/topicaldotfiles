#!/usr/bin/env bash
[[ "$1" == "source" ]] || \

echo 'Dotfiles - "Cowboy" Ben Alman - http://benalman.com/'

if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP

Usage: $(basename "$0")

See the README for documentation.
https://github.com/cowboy/dotfiles

Copyright (c) 2014 "Cowboy" Ben Alman
Licensed under the MIT license.
http://benalman.com/about/license/
HELP
exit; fi

###########################################
# GENERAL PURPOSE EXPORTED VARS / FUNCTIONS
###########################################

# if user has exported their own DOTFILES path already, use that
# instead of default (~/.dotfiles)
export DOTFILES=${DOTFILES-~/.dotfiles}

# Logging stuff.
function e_header()   { echo -e "\n\033[1m$@\033[0m"; }
function e_success()  { echo -e " \033[1;32m✔\033[0m  $@"; }
function e_error()    { echo -e " \033[1;31m✖\033[0m  $@"; }
function e_arrow()    { echo -e " \033[1;34m➜\033[0m  $@"; }

# For testing.
function assert() {
  local success modes equals actual expected
  modes=(e_error e_success); equals=("!=" "=="); expected="$1"; shift
  actual="$("$@")"
  [[ "$actual" == "$expected" ]] && success=1 || success=0
  ${modes[success]} "\"$actual\" ${equals[success]} \"$expected\""
}

# OS detection
function is_osx() {
  [[ "$OSTYPE" =~ ^darwin ]] || return 1
}
function is_ubuntu() {
  [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]] || return 1
}
function get_os() {
  for os in osx ubuntu; do
    is_$os; [[ $? == ${1:-0} ]] && echo $os
  done
}

# Remove an entry from $PATH
# Based on http://stackoverflow.com/a/2108540/142339
function path_remove() {
  local arg path
  path=":$PATH:"
  for arg in "$@"; do path="${path//:$arg:/:}"; done
  path="${path%:}"
  path="${path#:}"
  echo "$path"
}

# Given strings containing space-delimited words A and B, "setdiff A B" will
# return all words in A that do not exist in B. Arrays in bash are insane
# (and not in a good way).
# From http://stackoverflow.com/a/1617303/142339
function setdiff() {
  local debug skip a b
  if [[ "$1" == 1 ]]; then debug=1; shift; fi
  if [[ "$1" ]]; then
    local setdiffA setdiffB setdiffC
    setdiffA=($1); setdiffB=($2)
  fi
  setdiffC=()
  for a in "${setdiffA[@]}"; do
    skip=
    for b in "${setdiffB[@]}"; do
      [[ "$a" == "$b" ]] && skip=1 && break
    done
    [[ "$skip" ]] || setdiffC=("${setdiffC[@]}" "$a")
  done
  [[ "$debug" ]] && for a in setdiffA setdiffB setdiffC; do
    echo "$a ($(eval echo "\${#$a[*]}")) $(eval echo "\${$a[*]}")" 1>&2
  done
  [[ "$1" ]] && echo "${setdiffC[@]}"
}

# If this file was being sourced, exit now.
[[ "$1" == "source" ]] && return

user () {
  printf "\r  [ \033[0;33m??\033[0m ] $1\n"
}

link_file () {
  local src=$1 dst=$2

  local overwrite= backup= skip=
  local action=
  local backup_path=

  if [ -f "$dst" -o -d "$dst" -o -L "$dst" ]
  then
    if [ "$overwrite_all" == "false" ] && [ "$backup_all" == "false" ] && [ "$skip_all" == "false" ]
    then
      local currentSrc="$(readlink $dst)"

      if [ "$currentSrc" == "$src" ]
      then
        skip=true;
      else
        user "File already exists: $dst ($(basename "$src")), what do you want to do?\n\
        [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -n 1 action

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac
        echo ''
      fi
    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [ "$overwrite" == "true" ]
    then
      rm -rf "$dst"
      e_success "removed $dst"
    fi

    if [ "$backup" == "true" ]
    then
      backup_path="${backup_dir}/$(basename $dst)"
      mkdir -p "$backup_dir"
      mv "$dst" "$backup_path"
      backups_made=1
      e_success "moved $dst to ${backup_path}"
    fi

    if [ "$skip" == "true" ]
    then
      e_success "skipped $src"
    fi
  fi

  if [ "$skip" != "true" ]  # "false" or empty
  then
    ln -s "$1" "$2"
    e_success "linked $1 to $2"
  fi
}


# Ensure that we can actually, like, compile anything.
if [[ ! "$(type -P gcc)" ]] && is_osx; then
  e_error "XCode or the Command Line Tools for XCode must be installed first."
  exit 1
fi

# If Git is not installed, install it (Ubuntu only, since Git comes standard
# with recent XCode or CLT)
if [[ ! "$(type -P git)" ]] && is_ubuntu; then
  e_header "Installing Git"
  sudo apt-get -qq install git-core
fi

# If Git isn't installed by now, something exploded. We gots to quit!
if [[ ! "$(type -P git)" ]]; then
  e_error "Git should be installed. It isn't. Aborting."
  exit 1
fi

# Initialize.
if [[ ! -d $DOTFILES ]]; then
  # $DOTFILES directory doesn't exist? Clone it!
  e_header "Downloading dotfiles"
  git clone --recursive https://github.com/${github_user:-vhladama}/${github_reponame:-topicaldotfiles}.git --config branch.autosetuprebase=always $DOTFILES 
  cd $DOTFILES
  # temporary until we get changes merged into master
  git checkout baseTopics
elif [[ "$1" != "restart" ]]; then
  # Make sure we have the latest files.
  e_header "Updating dotfiles"
  cd $DOTFILES
  prev_head="$(git rev-parse HEAD)"
  git pull
  git submodule update --init --recursive --quiet
  if [[ "$(git rev-parse HEAD)" != "$prev_head" ]]; then
    e_header "Changes detected, restarting script"
    exec "$0" "restart"
  fi
fi

# Add binaries into the path
[[ -d $DOTFILES/bin ]] && PATH=$DOTFILES/bin:$PATH
export PATH

# Tweak file globbing.
shopt -s dotglob
shopt -s nullglob


# If backups are needed, this is where they'll go.
backup_dir="$DOTFILES/backups/$(date "+%Y_%m_%d-%H_%M_%S")"
backups_made=

install_dotfiles () {
  local overwrite_all=false backup_all=false skip_all=false

  # find subdirectories of topics-enabled, including symlinks
  for topic_dir in $(find -H "$DOTFILES/topics-enabled" -mindepth 1 -maxdepth 1 -type l -o -type d)
  do
    for src in $(find -H "$topic_dir" -maxdepth 2 -name '*.symlink' -not -path '*.git*')
    do
      dst="$HOME/$(basename "${src%.*}")"
      link_file "$src" "$dst"
    done
    init_file="${topic_dir}/init.sh"
    if [[ -f "$init_file" ]]; then
      echo "sourcing $init_file"
      cd $topic_dir
      source $init_file
      cd $DOTFILES
    fi
  done

  # Alert if backups were made.
  if [[ "$backups_made" ]]; then
    echo -e "\nBackups were moved to ~/${backup_dir#$HOME/}/"
  fi

  # All done!
  e_header "All done!"
}

install_dotfiles
